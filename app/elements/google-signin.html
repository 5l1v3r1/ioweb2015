<!--
Copyright 2015 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../bower_components/polymer/polymer.html">
<!-- <link rel="import" href="../bower_components/google-apis/google-js-api.html"> -->
<link rel="import" href="../bower_components/google-apis/google-client-api.html">

<!--
`<google-signin>` uses Google Sign-in 2.0 to authorize users using Google's
OAuth 2.0 flow. See https://developers.google.com/identity/sign-in/web/sign-in.

#### Example

    <google-signin></google-signin>

@element google-signin
-->
<!--
Fired when the signed in state of the user changes.

@event signin-change
@param {Object} detail
@param {Object} detail.signedIn True if the user is authenticated.
@param {Object} detail.user The current user.
@param {Object} detail.response The current user's token response.
-->
<!--
Fired when sign in fails for some reason.

@event signin-fail
@param {Object} detail
@param {Object} detail.error The reason for sign in failure.
-->
<polymer-element name="google-signin" attributes="clientId scopes signedIn load" hidden>
<template>
  <template if="{{load}}">
    <google-js-api on-js-api-load="{{onLoadAuth}}"></google-js-api>
  </template>
</template>
<script>
(function() {

  var AUTH_ENDPOINT = 'api/v1/auth';

  Polymer({
    publish: {
      /**
       * A Google Developers client Id.
       *
       * @attribute clientId
       * @type string
       * @default null
       */
      clientId: null,

      /**
       * A space-separated list of OAuth2 scopes.
       *
       * @attribute scopes
       * @type string
       * @default null
       */
      scopes: null,

      /**
       * If true, the is signed in.
       *
       * @attribute signedIn
       * @type bool
       * @default false
       */
      signedIn: false,

      /**
       * The logged in user.
       *
       * @attribute user
       * @type object
       * @default {}
       */
      user: null,

      /**
       * If true, the JS client library is loaded and auth is initialized.
       *
       * @attribute load
       * @type bool
       * @default false
       */
      load: false
    },

    created: function() {
      if (window.ENV === 'dev' || location.hostname === 'localhost') {
        this.cookiePolicy = 'single_host_origin';
      } else {
        this.cookiePolicy = location.protocol + '//' + location.host;
      }

      this.signinChangedHandler_ = this.signinChangedHandler.bind(this);
    },

    onLoadAuth: function(e, detail, sender) {

      gapi.load('auth2', function() {

        // Init auth.
        this.auth2 = gapi.auth2.init({
          client_id: this.clientId,
          scope: this.scopes,
          fetch_basic_profile: true,
          cookie_policy: this.cookiePolicy
        });

        this.auth2.isSignedIn.listen(this.signinChangedHandler_);
      }.bind(this));
    },

    signIn: function() {
      if (this.auth2.isSignedIn.get()) {
        return;
      }

      // Sign the user in.
      // this.auth2.signIn().then(function() {

        // Sign in user + offline access for server calls.
        // TODO: check with server if user already has token.
        this.auth2.grantOfflineAccess({'redirect_uri': 'postmessage'}).then(function(resp) {
          // We have a one time code, but we're not signed in yet with a current
          // user and access token. Stash the one time for signinChangedHandler
          // to post it to the server.
          this.oneTimeCode = resp.code;
        }.bind(this), this.onSignInError);
      // }.bind(this));
    },

    signOut: function() {
      this.auth2.signOut().then(function() {
        // Note: disconnect() revokes the user's token include the backend's
        // refresh token. This means other signed in devices/browsers would
        // be invalidated, resulting in the user never receiving notifications
        // on those devices :(.
        // this.auth2.disconnect(); // revoke oauth scopes.

      }.bind(this), this.onSignInError);
    },

    signinChangedHandler: function(signedIn) {
      this.signedIn = signedIn;
      this.currentUser = this.auth2.currentUser.get();

      var token = this.currentUser.getAuthResponse();

      if (this.signedIn) {
        if (this.oneTimeCode) {
          this.sendCodeToServer(this.oneTimeCode);
          this.oneTimeCode = null;
        }

        var profile = this.currentUser.getBasicProfile();
        this.user = {
          id: profile.getId(),
          name: profile.getName(),
          picture: profile.getImageUrl(),
          email: profile.getEmail(),
          tokenResponse: token
        }

        // Refresh the token 15 min before expiration time. This is important
        // if the user has the page open for a long period of time. The token
        // should remain valid without a page reload.
        // TODO: figure out if this is still need for Signin 2.0. The token may
        // refresh itself.
        //var refreshTokenMsTimeout_ = (new Date(token.expires_at) - new Date()) - (15 * 60 * 1000);
        // this.refreshTokenHandle_ = this.async(this.onLoadAuth, null, refreshTokenMsTimeout_);
      } else {
        this.user = null;
        this.signedIn = false;
        // this.cancelAsync(this.refreshTokenHandle_);
      }

      this.fire('signin-change', {signedIn: signedIn, user: this.user});
    },

    sendCodeToServer: function(oneTimeCode, opt_callback) {
      var xhr = new XMLHttpRequest();
      xhr.open('POST', AUTH_ENDPOINT);

      var token = this.auth2.currentUser.get().getAuthResponse();

      xhr.setRequestHeader('Authorization', 'Bearer ' + (token.id_token || token.access_token));
      xhr.setRequestHeader('Content-Type', 'application/json');

      xhr.onload = function(e) {

        if (e.target.status === 200) {
          opt_callback && opt_callback();
        } else {
          // TODO: signin in -> sign out -> sign in not working because the
          // server is responding with "fetchCredentials: not offline; refresh token is not set"}
          // and doesn't get a RT token. Not sure why.
          // TODO: call disconnect because token could not be saved?
          this.signOut(); // One-time token could not be saved in backend. Log user out.

          this.fire('signin-fail', {
            error: 'One-time token was not sent to server',
            oneTimeCodeFail: true
          });
        }
      }.bind(this);

      xhr.send(JSON.stringify({code: oneTimeCode}));
    },

    onSignInError: function(error) {
      console.error(error);
    }
  });

})();
</script>
</polymer-element>
