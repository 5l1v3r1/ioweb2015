<!--
Copyright 2015 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">

<script src="../../bower_components/es6-promise-2.0.1.min/index.js"></script>
<script src="webgl-globe-namespace.js"></script>
<script src="matrix4x4.js"></script>
<script src="shader-program.js"></script>
<script src="geometry.js"></script>

<!--
Makes a globe or whatever.

    <webgl-globe></webgl-globe>

@element webgl-globe
-->
<polymer-element name="webgl-globe" attributes="active cameraDistance fov location locationTarget offsetY transitionDuration">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
        height: 100%;
      }
      #canvas {
        width: 100%;
        height: 100%;
        position: absolute;
        bottom: 0;
      }
    </style>
    <canvas id="canvas"></canvas>
  </template>
  <script>
  (function() {
    /* global IOWA, ES6Promise */
    var ShaderProgram = IOWA.WebglGlobe.ShaderProgram;
    var Matrix4x4 = IOWA.WebglGlobe.Matrix4x4;
    var generateGeometry = IOWA.WebglGlobe.generateGeometry;
    var generateIndexArray = IOWA.WebglGlobe.generateIndexArray;

    /**
     * Polyfilled performance.now. Only good for relative timing, not absolute.
     * @type {function(): number}
     */
    var nowish = (window.performance && window.performance.now) ?
          window.performance.now.bind(window.performance) : Date.now;

    /**
     * Matrix used for ephemeral transformations.
     * @type {!Matrix4x4}
     */
    var tmpTransform = new Matrix4x4();

    // Trigger es6-promise
    ES6Promise.polyfill();

    Polymer({
      /**
       * Whether the globe should be rendered in the page. The first time this
       * attribute goes from false to true, the WebGL context and assets are
       * initialized and drawn to the screen. Any subsequent times it goes to
       * false and then back to true, the WebGL assets are retained and only
       * rendering is affected.
       *
       * @attribute active
       * @type bool
       * @default false
       */
      active: false,

      /**
       * The latitude and longitude of the location to focus on.
       *
       * @attribute location
       * @type object
       * @default {lat: 0, lng: 0}
       */

      /**
       * The latitude and longitude of the point at which to put `location`.
       * That is, the globe will be rotated such that `location` will be placed
       * where `locationTarget` is found when no rotation has been applied.
       *
       * @attribute locationTarget
       * @type object
       * @default {lat: 0, lng: 0}
       */

      /**
       * The distance from the camera to the center of the globe, in multiples
       * of radiuses of the globe (e.g. a value of 2 would place the camera one
       * radius above the surface of the globe).
       *
       * @attribute cameraDistance
       * @type number
       * @default 2
       */
      cameraDistance: 2,

      /**
       * The field of view angle for drawing the globe, in radians.
       *
       * @attribute fov
       * @type number
       * @default 1.0471975511965976
       */
      fov: Math.PI / 3,

      /**
       * An offset for the globe in the final Normalized Device Coordinates
       * space, which is relative to the height of the canvas element. For
       * example, an offset of 0.5 would move the entire scene up by 50% of the
       * canvas's height.
       *
       * @attribute offsetY
       * @type number
       * @default 0
       */
      offsetY: 0,

      /**
       * The duration over which transitions between locations should occur.
       *
       * @attribute transitionDuration
       * @type number
       * @default 2000
       */
      transitionDuration: 2000,

      /**
       * Whether WebGL rendering has been activated before.
       *
       * @property activated_
       * @type bool
       * @default false
       */
      activated_: false,

      /**
       * The previous location focused on.
       *
       * @property previousLocation_
       * @type object
       * @default {lat: 0, lng: 0}
       */

      /**
       * The current location being focuse on.
       *
       * @property currentLocation_
       * @type object
       * @default {lat: 0, lng: 0}
       */

      /**
       * The timestamp of the start of the location transition.
       *
       * @property transitionStart_
       * @type number
       * @default 0
       */
      transitionStart_: 0,

      /**
       * Shader program to render globe.
       *
       * @property globeProgram
       * @type ShaderProgram
       * @default null
       */
      globeProgram: null,

      /**
       * ArrayBuffer for globe geometry.
       *
       * @property globeArrayBuffer
       * @type WebGLBuffer
       * @default null
       */
      globeArrayBuffer: null,

      /**
       * ArrayBuffer for globe indices.
       *
       * @property globeIndexBuffer
       * @type WebGLBuffer
       * @default null
       */
      globeIndexBuffer: null,

      /**
       * World to Normalized Device Coordinates transform.
       *
       * @property projectionTransform_
       * @type Matrix4x4
       * @default null
       */
      projectionTransform_: null,

      /**
       * WebGL context.
       *
       * @property gl
       * @type WebGLRenderingContext
       * @default null
       */
      gl: null,

      /**
       * Whether to actively animate the globe.
       *
       * @property animate
       * @type boolean
       * @default false
       */
      animate: false,

      /**
       * Number of primitives to draw to render the globe.
       *
       * @property drawCount
       * @type number
       * @default 0
       */
      drawCount: 0,

      /**
       * The globe cubemap texture object.
       *
       * @property globeCubemap
       * @type WebGLTexture
       * @default null
       */
      globeCubemap: null,

      /**
       * Timeout for outliers on perf analytics.
       *
       * @property MAX_PERF_TIMEOUT_
       * @type number
       * @default 1000
       */
      MAX_PERF_TIMEOUT_: 1000,

      /**
       * Number of times to divide each edge of icosahedron geometry generator.
       * @property divisions_
       * @type number
       * @default 16
       */
      divisions_: 16,

      /**
       * True if the canvas has had its size changed and the scene needs to be
       * reconfigured.
       * @property resizeNeeded_
       * @type bool
       * @default true
       */
      resizeNeeded_: true,

      canvasResized: function() {
        this.resizeNeeded_ = true;
      },

      created: function() {
        this.projectionTransform_ = new Matrix4x4();

        // TODO(bckenny): why can't this be in created?
        this.location = {lat: 0, lng: 0};

        this.locationTarget = {lat: 0, lng: 0};
        this.previousLocation_ = {lat: 0, lng: 0};
        this.currentLocation_ = {lat: 0, lng: 0};

        this.resizeCallback_ = this.canvasResized.bind(this);
      },

      attached: function() {
        // start loading assets right away, but hold off on WebGL initialization
        this.loadingTextures_ = this.loadTextures_();
        this.loadingShaders_ = this.loadShaders_();

        if (this.active) {
          this.async(this.init_);
        }
      },

      activeChanged: function() {
        if (this.active) {
          if (!this.activated_) {
            this.init_();
          } else {
            this.animate = true;
            this.async(this.update_);
          }
        } else {
          this.animate = false;
        }
      },

      init_: function() {
        this.activated_ = true;

        var gl = this.gl = this.$.canvas.getContext('webgl');
        if (!gl) {
          // attempt with experimental
          gl = this.gl = this.$.canvas.getContext('experimental-webgl');

          if (!gl) {
            IOWA.Analytics.trackEvent('globe', 'webgl unsupported');
            // TODO(bckenny): give up
            return;
          }
        }

        window.addEventListener('resize', this.resizeCallback_);

        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);

        var startTime = nowish();
        var globeGeometry = generateGeometry(this.divisions_);
        var globeIndices = generateIndexArray(this.divisions_);
        var endTime = nowish();

        IOWA.Analytics.trackPerf('globe', 'geometry creation',
            Math.ceil(endTime - startTime), null, this.MAX_PERF_TIMEOUT_);

        this.globeArrayBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.globeArrayBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, globeGeometry, gl.STATIC_DRAW);

        this.globeIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.globeIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, globeIndices, gl.STATIC_DRAW);

        this.drawCount = globeIndices.length;

        Promise.all([
          this.loadingShaders_,
          this.loadingTextures_.then(this.initCubeMap_.bind(this))
        ])
          .then(function assetsLoaded(assets) {
            this.globeProgram = new ShaderProgram(this.gl, assets[0][0],
                assets[0][1]);
            this.globeProgram.use();
            this.gl.enableVertexAttribArray(this.globeProgram.attributes.coord);

            this.globeCubemap = assets[1];

            this.animate = true;
            this.async(this.update_);
          }.bind(this))
          .catch(function(reason) {
            // TODO(bckenny): give up
            IOWA.Analytics.trackError('globe initialization', reason);
          });
      },

      resize_: function() {
        var canvas = this.$.canvas;
        var resolutionScale = window.devicePixelRatio > 1 ? 2 : 1;
        var width = canvas.offsetWidth;
        var height = canvas.offsetHeight;
        canvas.width = width * resolutionScale;
        canvas.height = height * resolutionScale;
        this.gl.viewport(0, 0, width * resolutionScale,
            height * resolutionScale);

        var center = this.cameraDistance;
        this.projectionTransform_.identity()
          .translate(0, this.offsetY, 0)
          .perspective(this.fov, width / height, center - 1, center + 1);

        this.resizeNeeded_ = false;
      },

      loadShaders_: function() {
        return Promise.all([
          'shaders/simple.vert',
          'shaders/simple.frag'
        ].map(function(shaderUrl) {
          var resolvedUrl = this.resolvePath(shaderUrl);
          return new Promise(function(resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', resolvedUrl);
            xhr.onload = function(e) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(this.statusText);
              }
            };
            xhr.onerror = function(e) {
              reject(this.statusText);
            };
            xhr.send();
          });
        }, this));
      },

      loadTextures_: function() {
        // cube map GLenum constants from WebGL spec
        var globeFaces = {
          'negative-x.jpg': 0x8516,
          'negative-y.jpg': 0x8518,
          'negative-z.jpg': 0x851A,
          'positive-x.jpg': 0x8515,
          'positive-y.jpg': 0x8517,
          'positive-z.jpg': 0x8519
        };

        // load six face images and associate them with their face GLenum value
        return Promise.all(
          Object.keys(globeFaces).map(function(faceName) {
            return new Promise(function(resolve, reject) {
              var textureImage = new Image();
              textureImage.onload = function() {
                resolve({
                  target: globeFaces[faceName],
                  texture: textureImage
                });
              };
              textureImage.onerror = reject;
              textureImage.src = this.resolvePath('textures/' + faceName);
            }.bind(this));
          }, this)
        );
      },

      initCubeMap_: function(faceData) {
        var gl = this.gl;

        // create cubemap texture from six loaded images
        var textureStartTime = nowish();
        var textureId = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, textureId);
        for (var i = 0; i < faceData.length; i++) {
          gl.texImage2D(faceData[i].target, 0, gl.RGB, gl.RGB,
              gl.UNSIGNED_BYTE, faceData[i].texture);
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER,
            gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER,
            gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S,
            gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T,
            gl.CLAMP_TO_EDGE);
        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

        // better texture filtering through extensions
        var filterExtension =
            gl.getExtension('EXT_texture_filter_anisotropic') ||
            gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') ||
            gl.getExtension('MOZ_EXT_texture_filter_anisotropic');
        if (filterExtension) {
          // set to maximum anisotropic filtering if it exists
          // NOTE(bckenny): some platforms report support while setting
          // MAX_ANISOTROPY to 0. Override to the minimum of 2 (see spec) and
          // leave it to the platform to clamp if needed.
          var maxAnisotropy = gl.getParameter(
              filterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) || 2;
          gl.texParameterf(gl.TEXTURE_CUBE_MAP,
              filterExtension.TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);
        }

        var textureEndTime = nowish();
        IOWA.Analytics.trackPerf('globe', 'cubemap creation',
            Math.ceil(textureEndTime - textureStartTime), null,
            this.MAX_PERF_TIMEOUT_);

        return textureId;
      },

      latLngDistance_: function(p0, p1) {
        var lat0 = p0.lat * Math.PI / 180;
        var lat1 = p1.lat * Math.PI / 180;
        var deltaLng = (p1.lng - p0.lng) * Math.PI / 180;
        return Math.acos(Math.sin(lat0) * Math.sin(lat1) +
            Math.cos(lat0) * Math.cos(lat1) * Math.cos(deltaLng));
      },

      locationChanged: function() {
        // TODO(bckenny): for now, assume transition to current location has
        // been completed (so path is C0 but not C1).
        this.previousLocation_.lat = this.currentLocation_.lat;
        this.previousLocation_.lng = this.currentLocation_.lng;

        // since we're lerping in latlng space, check if the other way is faster
        if (Math.abs(this.previousLocation_.lng - this.location.lng) > 180) {
          if (this.previousLocation_.lng < this.location.lng) {
            this.previousLocation_.lng += 360;
          } else {
            this.previousLocation_.lng -= 360;
          }
        }

        this.transitionStart_ = nowish();
      },

      ease_: function(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      },

      lerp_: function(a, b, t) {
        return a + t * (b - a);
      },

      interpolateLocation_: function(timestamp) {
        var elapsedTime = timestamp - this.transitionStart_;
        var t = Math.max(0, Math.min(1, elapsedTime / this.transitionDuration));
        t = this.ease_(t);

        // TODO(bckenny): for now, just lerp in latlng space
        this.currentLocation_.lat = this.lerp_(this.previousLocation_.lat,
            this.location.lat, t);
        this.currentLocation_.lng = this.lerp_(this.previousLocation_.lng,
            this.location.lng, t);
      },

      update_: function(timestamp) {
        if (!this.animate) {
          return;
        }
        if (this.resizeNeeded_) {
          this.resize_();
        }
        if (timestamp - this.transitionStart_ < this.transitionDuration) {
          // TODO(bckenny): set animate = false when this is finished?
          this.interpolateLocation_(timestamp);
        }

        var gl = this.gl;

        // TODO(bckenny): don't necessarily need to do these every frame
        this.globeProgram.use();
        gl.vertexAttribPointer(this.globeProgram.attributes.coord, 4, gl.FLOAT,
            false, 16, 0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.globeCubemap);

        // globe to eye space
        var rotX = this.currentLocation_.lat - this.locationTarget.lat;
        var rotY = -this.currentLocation_.lng + this.locationTarget.lng;
        var worldTransform = tmpTransform.identity()
          .translate(0, 0, -this.cameraDistance)
          .rotateX(rotX * Math.PI / 180)
          .rotateY(rotY * Math.PI / 180);

        // set uniforms
        this.globeProgram.uniforms.globeMatrix(worldTransform.m_);
        this.globeProgram.uniforms.viewMatrix(this.projectionTransform_.m_);
        this.globeProgram.uniforms.globeCubemap(0);

        gl.drawElements(gl.TRIANGLES, this.drawCount, gl.UNSIGNED_SHORT, 0);

        if (this.animate) {
          window.requestAnimationFrame(this.update_.bind(this));
        }
      },

      detached: function() {
        this.animate = false;
        window.removeEventListener('resize', this.resizeCallback_);
      }
    });
  })();
  </script>
</polymer-element>
