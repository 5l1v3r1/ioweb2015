<!--
Copyright 2015 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/core-media-query/core-media-query.html">
<link rel="import" href="../bower_components/core-label/core-label.html">
<link rel="import" href="../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="io-radio-button.html">
<link rel="import" href="io-checkbox.html">

<!--
The `<io-schedule>` element renders a schedule for a given day(s).

@element io-schedule
-->
<polymer-element name="io-schedule" block>
  <template>
    <link rel="stylesheet" href="io-schedule.css" no-shim>

    <core-media-query query="(min-width:320px) and (max-width:767px)"
                      queryMatches="{{isPhoneSize}}"></core-media-query>
    <core-media-query query="(min-width:768px) and (max-width:1135px)"
                      queryMatches="{{isTabletSize}}"></core-media-query>
    <core-media-query query="(min-width:1136px)"
                      queryMatches="{{isDesktopSize}}"></core-media-query>

    <div class="card__container {{{'sidebyside': !isPhoneSize} | tokenList}}" layout
         vertical?="{{isPhoneSize}}" horizontal?="{{!isPhoneSize}}">
      <div flex?="{{!isPhoneSize}}" layout vertical>
        <template repeat="{{timeBlock in timeBlocks_}}">
          <template if="{{timeBlock.dayStart && !day && (timeBlock.dayStart <= lastDay_ && timeBlock.dayStart >= firstDay_)}}">
            <div class="card day-title">
              <div class="card-content">
                <h4>Day {{timeBlock.dayStart}}</h4>
              </div>
            </div>
          </template>
          <template if="{{(!day || timeBlock.day == day) && timeBlock.sessions.length}}">
            <div class="card">
              <div class="card-content">
                <h4>{{timeBlock.name}}</h4>
              </div>
              <paper-progress indeterminate hidden?="{{!fetchingUserData}}"></paper-progress>
              <div class="card-content schedule-rows"
                   layout vertical hidden?="{{!timeBlock.sessions.length}}">
                <template repeat="{{sessionId in timeBlock.sessions}}">
                  <div class="schedule-row" layout horizontal
                       center?="{{isDesktopSize}}"
                       hidden?="{{sessions[sessionId].hide}}">
                    <io-radio-button
                        on-change="{{onToggleSaveSession}}"
                        toggles checked?="{{sessions[sessionId].saved}}"
                        disabled?="{{showOnlySavedSessions}}"
                        aria-labelledby="session-{{sessionId}}-time session-{{sessionId}}-title"></io-radio-button>
                    <div layout vertical?="{{!isDesktopSize}}"
                         horizontal?="{{isDesktopSize}}" flex
                         on-click="{{selectSession}}"
                         tabindex="0">
                      <span class="schedule-time" flex auto-vertical id="session-{{sessionId}}-time">
                        {{sessions[sessionId].start}} <span hidden?="{{sessionId === '__keynote__'}}"> - {{sessions[sessionId].end}}</span>
                      </span>
                      <span class="schedule-title" auto-vertical
                            flex?="{{!isPhoneSize}}" two
                            title="{{sessions[sessionId].title}}"
                            id="session-{{sessionId}}-title">
                        {{sessions[sessionId].title}}
                        <core-icon class="schedule-livestream"
                            icon="io:videocam"
                            hidden?="{{!sessions[sessionId].isLivestream}}"></core-icon>
                      </span>
                    </div>
                  </div>
                </template>
              </div>
            </div>
          </template>

          <template if="{{timeBlock.dayStart && !day && !timeBlock.sessions.length && (timeBlock.dayStart <= lastDay_ && timeBlock.dayStart >= firstDay_)}}">
            <div class="card">
              <div class="card-content" layout horizontal?="{{!isPhoneSize}}"
                   vertical?="{{isPhoneSize}}" center?="{{!isPhoneSize}}" justified>
                <span class="no-sessions">Add more events for this day</span>
                <a href="#day{{timeBlock.day}}" data-subpage-link>Browse events</a>
              </div>
              <paper-progress indeterminate hidden?="{{!fetchingUserData}}"></paper-progress>
            </div>
          </template>

        </template>
      </div>

      <div class="card__container" layout vertical>
        <div class="card js-experiment-visualizer" hidden?="{{isPhoneSize}}">
          <div class="card-content">
            <h4 id="filters-header">Filters</h4>
          </div>
          <div class="card-content">
            <div id="filters">
              <div class="filter-rows filter-section">
                <template repeat="{{theme in sessionThemes}}">
                  <core-label center horizontal layout aria-labelledby="filters-header">
                    <div flex>{{theme}}</div>
                    <io-checkbox on-change="{{applyFilter}}"
                        checked?="{{filtersState_[theme]}}"
                        name="{{theme}}" for></io-checkbox>
                  </core-label>
                </template>
              </div>
              <div class="filter-rows filter-section">
                <template repeat="{{type in sessionTypes}}">
                  <core-label center horizontal layout aria-labelledby="filters-header">
                    <div flex>{{type}}</div>
                    <io-checkbox on-change="{{applyFilter}}"
                        checked?="{{filtersState_[type]}}"
                        name="{{type}}" for></io-checkbox>
                  </core-label>
                </template>
              </div>
              <div class="filter-rows filter-section">
                <core-label center horizontal layout aria-labelledby="filters-header">
                  <div flex>Live Streamed</div>
                  <io-checkbox on-change="{{applyFilter}}"
                      checked?="{{filtersState_['Live Streamed']}}"
                      name="Live Streamed" for></io-checkbox>
                </core-label>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </template>
  <script>
  (function() {

    var timeBlocks = [];
    var timeBlocksIndex = {};
    var populatedTimeBlocks_ = false;

    function populateTimeBlocks(gmtDayOne) {
      if (populatedTimeBlocks_) {
        return;
      }
      populatedTimeBlocks_ = true;
      var blocksStartDay = parseInt(moment(gmtDayOne).format('D'), 10);
      var hours = [];
      var generator = new Array(13);
      for (var i = 1; i < generator.length; i++) {
        hours.push(i + ' AM');
      }
      for (var i = 1; i < generator.length; i++) {
        hours.push(i + ' PM');
      }
      for (var i = 0; i < 3; i++) {
        for (var j = 0; j < hours.length; j++) {
          var timeBlock = {
            name: hours[j],
            day: blocksStartDay + i,
            sessions: []
          };
          if (j === 0) {
            timeBlock['dayStart'] = timeBlock.day;
          }
          timeBlocks.push(timeBlock);
          var timeBlockId = timeBlock.day + hours[j];
          timeBlocksIndex[timeBlockId] = timeBlocks.length - 1;
        }
      }
    }



    Polymer({

      publish: {
        /**
         * Optional day to filter the sessions, e.g. 'day1'.
         *
         * @attribute day
         * @type number
         * @default null
         */
        day: null,

        /**
         * Array of session theme names.
         *
         * @attribute sessionThemes
         * @type array
         * @default []
         */
        sessionThemes: [],

        /**
         * Array of session types.
         *
         * @attribute sessionTypes
         * @type array
         * @default []
         */
        sessionTypes: [],

        /**
         * Array of applied filters.
         *
         * @attribute filters
         * @type array
         * @default []
         */
        filters: [],

        /**
         * Timezone for the schedule times.
         *
         * @attribute timezone
         * @type string
         * @default 'GMT-07:00' (PDT timezone)
         */
        timezone: 'GMT-07:00',

        /**
         * List of timezones.
         *
         * @attribute timezoneNames
         * @type array
         * @default []
         */
        timezoneNames: [],

        /**
         * Array of scheduled sessions.
         *
         * @attribute sessions
         * @type array
         * @default []
         */
        sessions: [],

        /**
         * User's list of saved sessions.
         *
         * @attribute userSessions
         * @type array
         * @default []
         */
        userSessions: [],

        /**
         * Whether to show only saved sessions for any day.
         *
         * @attribute showOnlySavedSessions
         * @type Boolean
         * @default false
         */
        showOnlySavedSessions: false,

        /**
         * Logged in user.
         *
         * @attribute user
         * @type Object
         * @default null
         */
        user: null,

        /**
         * Whether fetching user data is in progress.
         *
         * @attribute fetchingUserData
         * @type Boolean
         * @default false
         */
        fetchingUserData: false,

        /**
         * WTimestamp for the start of the event in GMT timezone.
         *
         * @attribute gmtDayOne
         * @type string
         * @default null
         */
        gmtDayOne: null

      },

      timeBlocks_: timeBlocks,

      timeBlocksIndex_: timeBlocksIndex,

      sessionsIndex_: [],

      filtersState_: {},

      firstDay_: 28,  // of May, In GMT.

      lastDay_: 29,  // of May, In GMT.

      ready: function() {
        populateTimeBlocks(this.gmtDayOne);
      },

      sessionsChanged: function() {
        this.sessionsIndex_ = Object.keys(this.sessions);
      },

      dayChanged: function() {
        this.checkEmptyBlocks();
      },

      userSessionsChanged: function() {
        this.checkEmptyBlocks();
      },

      timezoneChanged: function() {
        var localFirstDay = this.getLocalizedTime(this.gmtDayOne);
        var localLastDay = localFirstDay.add(1, 'days');

        this.firstDay_ = localFirstDay.format('D');
        this.lastDay_ = localLastDay.format('D');
        for (var i = 0; i < this.sessionsIndex_.length; i++) {
          var session = this.sessions[this.sessionsIndex_[i]];
          var startTime = this.getLocalizedTime(session.startTimestamp);
          var endTime = this.getLocalizedTime(session.endTimestamp);
          session.start = startTime.format('h:mm A');
          session.end = endTime.format('h:mm A');
          session.block = startTime.format('h A');
          session.day = startTime.format('D');
        }
        this.checkEmptyBlocks();
      },

      isFilterSelected: function(filterName) {
        return this.filters.indexOf(filterName) > -1;
      },

      applyFilter: function(e) {
        var filterName = e.target.getAttribute('name');
        var filterIndex = this.filters.indexOf(filterName);
        if (e.target.checked && filterIndex < 0) {
          this.filters.push(filterName);
        } else if (!e.target.checked && filterIndex > -1) {
          this.filters.splice(filterIndex, 1);
        }
      },

      filtersChanged: function() {
        this.filtersState_ = {};
        for (var i = 0; i < this.filters.length; i++) {
          this.filtersState_[this.filters[i]] = true;
        }
        for (var i = 0; i < this.sessions.length; i++) {
          sessions[i].hide = !this.matchesFilters(sessions[i]);
        }
        this.checkEmptyBlocks();

        var filters = this.filters.join(',');
        var filterParam = '';
        if (filters.length) {
          filterParam = '?filters=' + encodeURIComponent(filters);
        }
        history.replaceState({}, '', [
          window.location.origin,
          window.location.pathname,
          filterParam,
          window.location.hash
        ].join(''));
      },

      matchesFilters: function(session) {
        if (!this.filters.length) {
          return true;
        }
        for (var i = 0; i < this.filters.length; i++) {
          if (session.filters[this.filters[i]]) {
            return true;
          }
        }
        return false;
      },

      checkEmptyBlocks: function() {
        for (var i = 0; i < this.timeBlocks_.length; i++) {
          this.timeBlocks_[i].sessions = [];
        }
        for (var i = 0; i < this.sessionsIndex_.length; i++) {
          var session = this.sessions[this.sessionsIndex_[i]];
          var block = session.day + session.block;
          if (this.timeBlocks_[this.timeBlocksIndex_[block]]) {
            var isValidSession = this.matchesFilters(session) &&
              (!this.showOnlySavedSessions ||
               (this.showOnlySavedSessions && session.saved));
            if (isValidSession) {
              this.timeBlocks_[this.timeBlocksIndex_[block]].sessions.push(
                this.sessionsIndex_[i]);
            };
          }
        }
      },

      selectSession: function(e, detail, sender) {
        this.fire('session-select', sender.templateInstance.model.sessionId);
      },

      filterSessions: function(items, day, block) {
        var filtered = [];
        for (var i = 0; i < items.length; i++) {
          var session = this.sessions[items[i]];
          if (session.day === day && session.block === block) {
            filtered.push(items[i]);
          }
        }
        return filtered;
      },

      /**
       * Converts a timestamp to a currently selected timezone.
       *
       * @method getLocalizedTime
       * @param {string} dateStr Timestamp string, e.g. '2015-05-28T16:00:00Z'.
       * @return {Object} A Moment object.
       */
      getLocalizedTime: function(dateStr) {
        var tzId = this.timezoneNames[this.timezone].name;
        return moment(dateStr).tz(tzId);
      },

      onToggleSaveSession: function(e, detail, sender) {
        e.stopPropagation();

        this.fire('session-bookmark', {
          sessionId: sender.templateInstance.model.sessionId,
          save: e.target.checked
        });
      }

    });

  })();
  </script>
</polymer-element>
